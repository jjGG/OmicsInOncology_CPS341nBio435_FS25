---
title: An R Markdown document converted from "Assignment-2024.ipynb"
output: html_document
editor_options: 
  markdown: 
    wrap: 72
---

# Omics in Oncology: Assignment + presentation

## Introduction

The study "Proteomics of Melanoma Response to Immunotherapy Reveals
Mitochondrial Dependence" by Harel et al. (2019) uses mass
spectrometry-based proteomics to analyze 116 melanoma tumors from
patients undergoing either *tumor-infiltrating lymphocyte (TIL)*-based
therapy (42 patients) or *anti-PD1 therapy* (74 patients). In this
study, patients were classified as responders to immunotherapy (partial
or complete response) or non-responders (progressive disease.\
Mass spectrometry analysis quantified over 10,300 proteins in patient
biopsies, with statistical analyses performed on \~4,500 proteins per
dataset. Differential protein expression was assessed using t-tests,
volcano plots, heatmap clustering methods, and enrichment analyses to
identify functional differences.\
Weighted gene correlation network analysis (WGCNA) was also applied to
associate protein clusters with clinical outcomes to TIL or anti-PD1
therapy. From this analysis the authors made some conclusion about what
mechanisms are driving immunotherapy resistance in patients. For
example, patients who responded to treatment had higher oxidative
phosphorylation and lipid metabolism signatures in their proteome data.
These signatures were associated with increased antigen presentation and
IFN signaling.\
From their analysis, the authors concluded that mitochondrial metabolism
plays a crucial role in shaping tumor immunogenicity and response to
immunotherapy.

What else can we learn from this interesting proteomics dataset? For
your final assessment, it is time for you to apply your data analysis
skills to dig deeper into the data and see what biological inferences
can be made to understand how patients respond to immunotherapy at a
molecular level. Check out the Harel et al. 2019 publication for
inspiration in your data analysis.

Using the provided proteomics data from the TIL patient cohort this
manuscript, apply the programming skills you learned to complete the
following assignment tasks:

## Overview

For this assignment we want you to:

1.  Load in the data from the cell paper CELL-179 supplementery data 1.
    We focus on the anti-PD1 data of this experiment.
    -   The ExpSetup data is in the *S1A* sheet
    -   The PD data is in the S1D sheet
2.  Perform a **T-test** on the PD data to get the most significantly
    changed proteins between Responders and Non responders.
3.  Create a **volcano plot** and label the top 10 proteins and color
    the significant up/down regulated proteins.
4.  Create a **heat map** of the top 10 most significantly changing
    proteins to see if there are any patterns
5.  With the t-test and volcano plot you can start the network and
    enrichment analysis
    -   Get the 1000 most significant proteins from our test
    -   Find which proteins are interaction according to the **String
        database** and export this network/graph
    -   Extract communities from the network using the igraph package.
        The result will contain 3 big clusters that we're interested in
        and some clusters with just a few proteins.
6.  Based on your group number you have to investigate cluster 1, 2 or 3
    further. We will perform an enrichment analysis on your (sub)
    cluster

## R libraries

Below are the libraries you need for this assignment. You can run the
chunk to have the correct packages installed.

```{r libraries, include=FALSE}


if (! "BiocManager" %in% installed.packages()[,1]) {
  install.packages("BiocManager")
}

library(BiocManager)

needed_packages <- c("tidyr", "dplyr","stringr", "purrr", "readr", "magrittr", "readxl", "writexl", "tidyHeatmap", "RBGL", "igraph", "ggplot2", "ggrepel")

for (package in needed_packages) {
  if(! package %in% installed.packages()[,1]) {
    install(package, update = FALSE, ask=FALSE)
  }
  library(package, character.only = TRUE)
}

```

# Reading in the files

This part of the code you get for free, to make sure, everyone has the
correct data. The Excel file downloaded from the Cell journal website
has different sheets for the supplementary tables. Here we will read the
correct sheets. Also they have added a line above each sheet with some
minor info, that we will need to skip.

```{r file reading}
## The experimental setup (which tells which patient is a responder and who is not) in Sheet S1A
## First, we'll read it into the ExpSetup variable
ExpSetup <- read_xlsx("CELL-179-suppl1.xlsx", sheet="S1A", na="NaN", skip = 1)

# Rename a few columns
ExpSetup %<>% rename(Sample="Sample ID", Age = "Age at treatment")

# remove some non essential columns
ExpSetup %<>% select(-c("Nb of CD8 cells in infusion bag (x10^10)", "Sample taken after treatment"))

# The authors were sloppy and sometimes forgot an underscore in the Sample names. Not handy as this causes issues in combining the data later on.
ExpSetup %<>% mutate(Sample = str_replace(Sample, " ", "_"))

## Sheet S1D contains the actual quantitative data
## We'll read it into the PDdata variable 
PDdata_raw <- read_xlsx("CELL-179-suppl1.xlsx", sheet="S1D", na="NaN", skip = 1)
```

## Inspecting the imported data

Make sure the data is correct by having a look at the table

```{r inspect ExpSetup}
## You: Output ExpSetup, to check if all the steps above have worked

head(ExpSetup)
```

You need to still check if the name of your PD dataset (below it is
called PDdata) is the same as yours. If not you need to change either
your variable name, or the code below so that these match.

Also this step you get for free: We combine the ExpSetup with the
quantitative data.

```{r Combine expsetup with quant data }


# The names are a bit confusing, let's first fix that
PDdata_raw %<>%
    rename(Gene_name = "T: T: Gene name",
           Ensembl_accession = "T: ENSP",
           Protein_name = "T: Protein name",
           Uniprot_accession = "T: Uniprot")

# Because sometimes we have multiple names for the gene names and accessions,
# we are only going to look at the first ones.
# We use the 'purrr' library to be able to use map_chr.
# This is a bit more advanced code as well, so don't worry about it.
# the result is that the columns with multiple values only show the first value from now on.

PDdata_raw %<>%
    mutate(Gene_name = map_chr(Gene_name, ~{ str_split_i(.x, ";", 1)} ), 
           Ensembl_accession = map_chr(Ensembl_accession, ~{ str_split_i(.x, ";", 1)} ), 
           Uniprot_accession = map_chr(Uniprot_accession, ~{ str_split_i(.x, ";", 1)} ), 
           Protein_name = map_chr(Protein_name, ~{ str_split_i(.x, ";", 1)} ))

# Here we take all the column titles that start with "PD", and use them as a
# variable (column) called "Sample"
# The numbers in these columns is stored in a column called "Expression"
# All remaining columns still exist and the values are duplicated as needed so they
# still correspond to the correct expression values

PDdata <- PDdata_raw %>%
    pivot_longer(starts_with("PD"), names_to = "Sample", values_to = "Expression") %>%
    relocate(c(Sample, Expression))

## the data from the ExpSetup table is combined with the PDdata table, based on 
## where the Sample column values are the same between them
PDdata %<>% left_join(ExpSetup, by="Sample")

## The 'response' variable now has three levels: PR, CR are responders, PD are non-responders
## we're going to convert the Response into, with values NR (no respones) or R (response) based on this information

PDdata %<>% mutate(Response = ifelse(Response=='PD', "NR", "R"))
```

## Plot a histogram of one protein

Take the data, and use 'filter' to extract a single protein **PSME1**.
Use ggplot to create a histogram. Of the histogram bars, make 'fill' of
the histogram from the Response variable. Discuss what you observe in
this plot.

```{r create histogram of expression values}
PSME1_data <- PDdata %>% filter(Gene_name == "PSME1")
ggplot(PSME1_data, aes(x = Expression, fill = Response)) +
    geom_histogram(binwidth = 0.5, alpha = 0.7, position = "identity") +
    labs(title = "Histogram of PSME1 Protein Expression",
         x = "Expression Level",
         y = "Count",
         fill = "Response") +
   scale_fill_manual(values = c("NR" = 'yellow', "R" = "darkblue"),
                      labels = c("NR" = "Not Responsive", "R" = "(Partially) Responsive")) +
    theme_minimal()

```
The histogram shows the distribution of PSME1 expression across the two different samples: non-responsive and responsive/partially responsive. PSME1 expression is higher in Responders to immunotherapy, which would indicate an association with treatment response. However, the distributions overlap quite a bit, meaning that PSME1 might not be a good predictor for immunotherapy response. We'll need a statistical test to quantify its predictive value. 

# Statistical analysis

## Perform t-tests

We have now given you an idea of how a single protein expression behaves
between two situations, but now let's get a bit more systematic. We'll
do a statistical test to see if protein expression is different between
non-responders and the responders.

The following code does the following things:

-   group all genes, and for each gene calculate a t-test of expression
    vs response and store the p-value
-   calculate the fold change, which is the difference between the
    median expression of response / no response
-   remove the original data
-   sort the table according to the p-value (low -\> high)
-   perform an operation so that the fold_change is centered around 0,
    by subtracting the median of all fold_changes

The results are stored in a table t_tests

```{r perform t-tests}

# for readability, this is a function to calculate the fold_change column for each protein
fold_change <- function(gene_table) {
  medians <- tapply(gene_table$Expression, gene_table$Response, median, na.rm=TRUE)
  # The data is already in log2 scale, so the values are simply subtracted
  return( medians["R"] - medians["NR"] )
}

t_tests <- PDdata %>% 
  group_by(Gene_name) %>%
  nest() %>%
  mutate(p_value = map_dbl(data, function(x) { return (t.test(x$Expression ~ x$Response)$p.value)})) %>%
  mutate(fold_change = map_dbl(data, fold_change)) %>%
  select(-data) %>%
  arrange(p_value) %>%
  ungroup() %>%
  mutate(fold_change = fold_change - median(fold_change))
```

### Inspect the contents of the t_tests table

use the 'head' function to show the **10** proteins with the lowest
p-values. As you can see PSME1 is indeed upregulated (fold_change\>0).

```{r show t_tests}
head(t_tests, 10)

```

### Check histograms to see if the fold_change makes sense

Make some histograms like the one above, but now for different proteins
with different fold_changes, so you can show if the values from the
table make sense.

```{r investigate with histograms}
# We want to compare histograms for proteins with different fold_changes, and want to pick one protein that is upregulated (high positive fold change), one that is downregulated (high negative fold change), and no significant change (fold change around zero). 
top_upregulated <- t_tests %>% filter(fold_change == max(fold_change)) %>% pull(Gene_name)
top_downregulated <- t_tests %>% filter(fold_change == min(fold_change)) %>% pull(Gene_name)
neutral_protein <- t_tests %>% filter(abs(fold_change) == min(abs(fold_change))) %>% pull(Gene_name)


# For these histograms S100B (upregulated), POTEE (downregulated), and ILKAP (neutral) were selected. We will create a function to code for all three histograms. 

plot_histogram <- function(protein) {
  protein_data <- PDdata %>% filter(Gene_name == protein)
  
  ggplot(protein_data, aes(x = Expression, fill = Response)) +
    geom_histogram(binwidth = 0.5, alpha = 0.7, position = "identity") +
    labs(title = paste("Histogram of", protein, "Expression"),
         x = "Expression Level",
         y = "Count",
         fill = "Response") +
    scale_fill_manual(values = c("NR" = "yellow", "R" = "darkblue"),
                      labels = c("NR" = "Non-responsive", "R" = "(Partially) Responsive")) +
    theme_minimal()
}

plot_histogram(top_upregulated)
plot_histogram(top_downregulated)
plot_histogram(neutral_protein)

```
The histograms show that in upregulated proteins like S100B the protein expression level is very low in non-responsive samples, and high in responsive samples; in downregulated proteins like POTEE expression levels are higher in non-responsive samples compared to responsive ones; and for neutral proteins like ILKAP the two samples overlap in protein expression.

## Creating a volcano plot

We want to create a volcano plot, so we will need a fold change. In this
case we'll calculate that based on the median Expression value for every
gene.

This part of the code, you again get for free... Make sure you have all
the variables needed to run this code:

-   We define significance 'up' vs 'down' or non-significant 'ns'

-   The limits for these are, p-value \<= 0.05, and the fold change

```{r}
# Create new column with 'up', 'down'
diseased_vs_healthy <- t_tests %>%
  mutate(significance = case_when((fold_change >= 0.3 & p_value <= 0.05) ~ "up",
                               (fold_change <= -0.3 & p_value <= 0.05) ~ "down",
                               TRUE ~ "ns"))

head(diseased_vs_healthy)

# Obtain significance counts
diseased_vs_healthy %>%
  count(significance)
```

The following code is given, make sure you understand what everything
means!

```{r}

## This line finds the top 50 significant names of the proteins (change this number to see more or less labels)
sig_il_genes <- diseased_vs_healthy %>% filter(significance != "ns") %>% slice(1:10) %>%
  pull(Gene_name)

# Let's prepare some colors and sizes that we will use in the plot

cols <- c("up" = "pink", "down" = "lightblue", "ns" = "lightgrey") 
sizes <- c("up" = 2, "down" = 2, "ns" = 1) 

diseased_vs_healthy %>%
  ggplot(aes(x = fold_change,
             y = -log10(p_value),
             fill = significance,
             size = significance)) +
  geom_point(shape = 21) +
  geom_hline(yintercept = -log10(0.05),
             linetype = "dashed") +
  geom_vline(xintercept = c(-0.3, 0.3),
             linetype = "dashed") +
  scale_fill_manual(values = cols) + # Modify point colour
  scale_size_manual(values = sizes) + # Modify point size
  geom_label_repel(data = sig_il_genes, # Add labels last to appear as the top layer  
                   aes(label = Gene_name),
                   force = 2,
                   nudge_y = 1) +
  scale_x_continuous(limits=c(-3,3)) +
  theme_minimal()
```

## Create a heatmap

From the analysis created above, extract the values from the 10 most
significant proteins and plot the expression values as a `heatmap`. The
horizontal axis can be Gene_name, the vertical axis contains all
samples.

Create an `annotation_tile` based on the Response for each each patient
sample.

```{r}
## create the heatmap

# We will use the top 10 most significant proteins, already defined in sig_il_genes in the last chunk, we just added '%>% pull(Gene_name)' after it.
# So, now we can create a heatmap data set. 

heatmap_data <- PDdata %>%
  filter(Gene_name %in% sig_il_genes)

# But we have to reshape the data, because now the samples are row, and we want the genes to be rows and the samples to be columns. 
heatmap_matrix <- heatmap_data %>%
  select(Sample, Gene_name, Expression) %>%
  pivot_wider(names_from = Sample, values_from = Expression)
# The only problem now is that gene names are now in the first column, instead of being row names.
heatmap_matrix <- as.data.frame(heatmap_matrix)
rownames(heatmap_matrix) <- heatmap_matrix$Gene_name # Change row numbers to gene names. 
heatmap_matrix <- heatmap_matrix[, -1] # And then remove the first column that contained the gene names. 

# Okay, now the data is prepped and we can continue with plotting the heatmap :)

# We get an error... It has something to do with the missing values in the data. We asked ChatGPT for help, and replace all 'NA' values with the row median. 
heatmap_matrix <- t(apply(heatmap_matrix, 1, function(row) {
  row[is.na(row)] <- median(row, na.rm = TRUE)  # Replace NA with row median
  return(row)
}))

library(pheatmap)
pheatmap(heatmap_matrix, 
         scale = "row", # Standardize expression levels across genes
         clustering_method = "complete",
         color = colorRampPalette(c("lightblue", "lightgrey", "pink"))(50), # Define color gradient
         main = "Heatmap of Top 10 Significant Proteins")


```

# Network analysis

We're going to try to find some biological meaning in our data. For that
we'll use the String database, that has been presented before.

We'll do a network query with significant proteins from the t_tests
table that you created also for the volcano plot. We'll take the top
1000 most significantly changed proteins and upload those to the String
database. We'll then get a network with the existing interactions, that
we can analyze to extract protein networks from the huge fuzz ball.

### Create the list with proteins

First you will need to get the top-1000 protein names from the list of
significant proteins. Use the R `write` function to create a text file
with just the names of the proteins. The dplyr `pull` and `slice`
functions can be helpful here.

```{r}

```

Go to the string-db.org site, and upload the top1000.txt file to the
multiple proteins input. Make sure the organism is set to **Homo
sapiens**, and show the found network.

### Export the network from string-db.org

Below the network (hairball), select the Exports tab. Export as a short
tabular text output, but also as a graphical file for the presentation.
Place this file in your project folder, and read it in. Find the correct
columns to use in the graph that we're going to use.

Create the protein graph from the imported table, using the function
`graph_from_data_frame` from the igraph package (already loaded). When
you have created the graph, it's necessary to also use the `simplify`
function on it to make the data less complex.

To get an idea about the connectivity of the graph, create a histogram
of the degrees in the graph.

```{r read in the exported graph data}
string_network <- read_delim("string_interactions.tsv", delim="\t")

#proteingraph <- 

```

The following code will extract the networks from your protein graph
(given). You can also see a graphical representation of the clusters.

```{r detect clusters and plot}

clusterList <- cluster_fast_greedy(proteingraph)

plot(clusterList, proteingraph)

```

### Extract the lists from the clusters

In order to get the clusters, you will need to extract them from the
clusterList, you can use the `communities` function.

```{r extract community clusters}

clusters <- communities(clusterList)
```

We're going to focus on the 3 largest clusters. Each group is working on
a subset.

-   Group 1: Will work with cluster 1 (clusters[[1]])
-   Group 2: Will work with cluster 2 (clusters[[2]])
-   Group 3: Will work with cluster 3 (clusters[[3]])
-   Group 4: Will work with cluster 1 (clusters[[1]])
-   Group 5: Will work with cluster 2 (clusters[[2]])
-   Group 6: Will work with cluster 3 (clusters[[3]])
-   ...
-   Use your clusters for further sub-clustering and subsequent
    enrichment analysis of the subclusters.
-   Try to identify which functions, kinds of proteins, cellular
    localization, enzymatic activities are enriched.
-   Put these enrichment in context of cancer. Did you find hallmarks?
    Important protein complexes/functions that play a role in cancer?
    And discuss this in your presentation.

# Prepare a Presentation

-   Make a powerpoint presentation of 10-15 minutes.
-   Explain the steps you have performed, but don't use R code. Explain
    it in simple steps.
-   Show your heatmap(s) and volcano plots, and provide some insights.
-   Show the results of your String clusters, subclusters and the main
    outcome(s) of your enrichment analysis
-   Explain the results of your enrichment in context of cancer. What do
    you finding suggest, or point at? Can you explain the roles of the
    proteins etc.
